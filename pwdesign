I have various pieces of a password manager.

Done stuff
----------
A plain text to JSON password converter. You still have to edit the free-form text file and then "compile" it though. The result is JSON, unencrypted

A command line password lookup utility. Uses the above-described unencrypted files. Also Python.

An Android password lookup utility. This shows the weakness of the current systen. The file is baked into the app's source code, which is obviously unworkable. The app, does however have some of the tedious work complete: parsing the JSON, implementing an autocomplete textbox.

A separate Java application that takes care of decrypting files that were encrypted with OpenSSL's AES encryption facility. These files have a special header and require some OpenSSL code ported to Java in order to work.

Not done stuff
--------------

A coherent design. The general thrust would be to have a secure way of 
making a password helper available everywhere. Something like:

The user creates a list of passwords, encrypts it (AES, or maybe libsodium),  then submits it to the server for secure storage.

The user then retrieves the file from the server when needed, and then can use it in some application. Maybe they can supply an expiry time for the data, after which it will vanish. or perhaps vanishing happens on application close.

Not sure what kind of crypto to use. I think there are two tasks:

 1.) Encrypting the file. The server should have just the cyphertext. This
     could be AES, or use the libsodium crypto

 2.) An extra layer of security is having to authenticate to retrieve the
     cyphertext. A private/public key scheme would be appropriate here, but
     not sure how easy that is to get into an app.

Is it feasible to use a libsodium keypair for two purposes: encrypt the file and also serve as an authentication mechanism for retrieval? One problem is password protection of the secret key. OpenSSL and RSA support this, but NaCl doesn't. If all this would work, there would be one secret for everything. Maybe AES encrypt the secret key?

Ideally, I wanted no secrets stored persistently, but maybe that's not possible.

How do signatures fit in here (or do they?)

Exploring the public key route, how does it work? One problem is that you're essessentially trying to encrypt a file for yourself. Public key is more oriented to message exchange between two parties, because the recipient's public key is part of it. I suppose you could just use your own public key. A little weird, but
 it seems like it would work. On the retrieval side, you encrypt something.

Maybe the components are:

- Generate a signing keypair.

- Choose a password to be used for generating the encryption key.

- AES encrypt both the private key and the password data using the secret
  key.

- Remember the password used to create the encryption key. The salt created
  during the AES encrypt will be in encoded in the two encrypted documents
  (the secret key and the password).

- Distribute the signing public key and the encrypted password data
  to the server.

- At retrieval time, decrypt the signing private key, sign a retrieval
  request (which can be plaintext) and send to the server, along with
  the signing public key.. 

- The server verifies the request using the offered public key and the
  signature. If this succeeds, use the public key to find the encrypted
  password data file and return it.

- On receipt of the encypted password file, decrypt the with the secret key.


 